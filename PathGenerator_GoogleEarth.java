package Homework4;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.StringTokenizer;

/**
 * Generate a KML file which shows 1 route generated by Prim Algorithm and another route generated by the permutation
 * @author vivekahong
 *
 */
public class PathGenerator_GoogleEarth {
	static double minLength = Double.MAX_VALUE;    //keep track of the min distance
	static List<Integer> optimal = new LinkedList<Integer>();  //keep track of which combination is the best
	public static void main(String[] args){
		String fileName = "CrimeRecord.txt";
		int numOfRecords = 0;
		String[] selectedCrimes = null;
		
		try{
			FileReader file = new FileReader(fileName);
			@SuppressWarnings("resource")
			BufferedReader buf = new BufferedReader(file);
			
			@SuppressWarnings("resource")
			Scanner scan = new Scanner(System.in);
		    System.out.println("Enter start index: ");
		    int start = scan.nextInt();
		    scan.nextLine();
		    System.out.println("Enter end index: ");
		    int end = scan.nextInt();
		    
		    numOfRecords = end - start + 1;
		  //System.out.println(numOfRecords);
		    selectedCrimes = new String[numOfRecords];  //storing the selected crime records
		    
		    int trigger = start;   // start putting the record into the array when the trigger is equal or below zero
		    int countRecords = 0;  // number of records selected
		    
		    String line = "";
		    System.out.println("Crime Records Processed: ");
		    System.out.println();
		    while((line = buf.readLine()) != null && countRecords < numOfRecords){
		    	if(trigger <= 0){
			    	selectedCrimes[countRecords++] = line;
			    	System.out.println(selectedCrimes[countRecords-1]);
		    	}
		    	trigger--;
		    }
		    System.out.println();
		    
	    }catch(FileNotFoundException e){
	    	System.out.println("Unable to open file " + fileName);
	    }catch(IOException ex){
	    	System.out.println("Having issue with reading the records");
	    }
		
		LinkedList<Coordinates> list = new LinkedList<Coordinates>();  // Coordinates
		
		for(int i = 0; i < numOfRecords; i++){
			StringTokenizer token = new StringTokenizer(selectedCrimes[i], ",");
			double x = 0, y = 0, lon = 0, alti = 0;
			int count = 5;
			try{
				x = Double.parseDouble(token.nextToken());
                y = Double.parseDouble(token.nextToken()); 
                while(count > 0){
                	token.nextToken();
                	count--;
                }
                lon = Double.parseDouble(token.nextToken()); 
                alti = Double.parseDouble(token.nextToken()); 
                count = 5;
			}catch(NumberFormatException nfe){
				System.out.println("NumberFormatException " + nfe.getMessage());
			}
			Coordinates coor = new Coordinates(x, y, lon, alti);
			list.add(coor);
		}
		
		// Coordinate arrays
		Coordinates[] coord =  list.toArray(new Coordinates[0]);
		
		/*Coordinate test
		for(int i = 0; i < numOfRecords; i++){
			System.out.println(((Coordinates) coord[i]).getX() + ", " + ((Coordinates) coord[i]).getY());
		}
	    */
		
		// Adjacency Matrix
		Double[][] distance = new Double[numOfRecords][numOfRecords];
		double x1, x2, y1, y2;
		
	    for(int i = 0; i < numOfRecords; i++){
	    	for(int j = 0; j < numOfRecords; j++){
	    		 x1 = coord[i].getX();
	    		 y1 = coord[i].getY();
	    		 x2 = coord[j].getX();
	    		 y2 = coord[j].getY();
	    		 distance[i][j] = (Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2)));
	    		 //System.out.println(distance[i][j]);
	    		 
	    	}
	    }
	    
	    /*Check out the adjacency matrix for the tree
	    for(int i = 0; i < numOfRecords; i++){
	    	for(int j = 0; j < numOfRecords; j++){
	    		System.out.printf("%.2f ", distance[i][j]);
	    	}
	    	System.out.println();
	    }
	   */
	    // Longitude and Latitude of the optimal combination route
	    String coordinates = Prim(coord, distance, 0);
	    String optCoordinates = "";
	    
	    // Constructor a list of coordinate for the optimal combination of route
	    List<Integer> list1 = new LinkedList<Integer>();
	    for(int i = 0; i < coord.length; i++){
			list1.add(i);
		}
	    System.out.println();
	    permutation(list1, 0, distance);
	    System.out.println();

	    System.out.print("Hamiltonan Cycle (minimal): ");
	    System.out.println();
	    Integer[] opt = optimal.toArray(new Integer[0]);
	    for(int i = 0; i < opt.length; i++){
	    	System.out.println(coord[opt[i]].getAlti() + "," + coord[opt[i]].getLon());
	    	optCoordinates += coord[opt[i]].getAlti() + "," + coord[opt[i]].getLon() + "0.000000\r\n";
	    }
	    System.out.println("Length of Cycle:  " + (minLength) + " miles");
	   
	    
	    String fileName1 = "PGHCrimes.kml";
	    try {
			FileWriter filewriter = new FileWriter(fileName1);
			
			BufferedWriter bufw = new BufferedWriter(filewriter);
			bufw.write(KML_p1);
			bufw.write(coordinates);
			bufw.write(KML_p2);
			bufw.write(optCoordinates);
			bufw.write(KML_p3);
			bufw.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    System.out.println();
	    System.out.println("PGHCrimes.kml has been generated....");
	}
	
	/**
	 * Process the selected crime record using Prim Algorithm </p>
	 * Pre-condition: adjacency matrix is not null and with correct values <br>
	 * Post-condition: Hamiltonian cycle and length have been generated
	 * @param G  coordination array for each record
	 * @param w  adjacency matrix
	 * @param r  index of starting location
	 */
	public static String Prim(Coordinates[] G, Double[][] w, int r){
		MinHeap Q = new MinHeap(G.length);
		//System.out.println(G.length + " G ");
		int[] parents = new int [G.length];        //parent indicator

		double[] key = new double [G.length];      //key with values
		
		for(int j = 0; j < key.length; j++){      //default values for all keys
			key[j] = Double.POSITIVE_INFINITY;
		}
		
		//set value for the root vertices
		key[r] = 0.00;
		parents[r] = r;
		Node node = new Node(r, key[r]);
		
		//insert the first root vertex with value 0 into the Min heap
		Q.insert(node);             
		
		for(int k = 0; k < G.length; k++){         //insert all vertex with their keys into the min heap
			if(k != r)
			Q.insert(new Node(k, key[k]));
		}
		
		Q.minHeap();  //rearrange min heap
		
		while(!Q.isEmpty()){

			int u = Q.deleteMin().getVertex();
			//System.out.println("Extracted Min Key: " + u);
			for(int l = 0; l < G.length; l++){
				if(w[u][l] < key[l] && w[u][l] != 0 && Q.containsValue(l)){
					key[l] = w[u][l];
					Q.modify(l, key[l]);
					parents[l] = u;
				}
			}

			Q.minHeap();
		}
        
        //Generating tree nodes
		treeNode[] nodes = new treeNode[parents.length];
		for(int j = 0; j < parents.length; j++){
			nodes[j] = new treeNode(j);
		}
		treeNode root = nodes[r];
		
		//Constructing a tree
	    for(int m = 0; m < parents.length; m++){
			if(m != r){
		    	nodes[m].setParent(nodes[parents[m]]); 
		        nodes[m].setLen(w[parents[m]][m]);
		        //System.out.println(nodes[m].getRecord() + " with " + nodes[m].getLen() + " has parent " + nodes[m].getParent().getRecord());
			}   
	    }
	 
	    
	    root.preOrderTraversal();
	    
	    //calculating the total cycle length
	    double length = 0;
	    
	    treeNode[] arr_test = root.getHamilCycle().toArray(new treeNode[0]);
	    for(int n = 0; n < arr_test.length-1; n++){
	    	//System.out.println("Sum of " + arr_test[i].getRecord() + " and " + arr_test[i+1].getRecord());
	    	length += w[arr_test[n].getRecord()][arr_test[n+1].getRecord()];
	    }
        
	    length = length * 0.00018939;
	    //System.out.println(r + " with Length: " + length);

		System.out.print("Hamiltonan Cycle: ");
		System.out.println();
		
		String coordinate = "";
		for(int i = 0; i < arr_test.length; i++){
				System.out.println(G[arr_test[i].getRecord()].getAlti() + "," + G[arr_test[i].getRecord()].getLon());
				coordinate += G[arr_test[i].getRecord()].getAlti() + "," + G[arr_test[i].getRecord()].getLon() + "0.001," + "0.000000\r\n";
		}
		
	    System.out.printf("Length of Cycle: %.2f miles", length);
	    return coordinate;
}
	
	/**
	 * Find out all possible combination of routes that provides the minimum distance of travel to each selected location</p>
	 * @param G List of selected crime records
	 * @param k Starting point
	 * @param w Adjacency matrix
	 */
	static void permutation(List<Integer> G, int k, Double[][] w){
		List<Integer> arr = G;
		for(int i = k; i < arr.size(); i++){
			Collections.swap(arr, i, k);
			permutation(arr, k+1, w);
			Collections.swap(arr,  k,  i);
		}
		
		if(k == arr.size() -1){
			
			double length = 0;
			for(int j = 0; j < arr.size()-1; j++){
			    length += w[arr.get(j)][arr.get(j+1)];
			    //System.out.println(arr.get(j) + " added with " + arr.get(j+1));
			}
			length += w[arr.get(arr.size()-1)][arr.get(0)];
			//System.out.println(arr.get(arr.size()-1) + " added with " + arr.get(0));
			length = length * 0.00018939;
			//System.out.println(java.util.Arrays.toString(arr.toArray()) + " with Length: " + length);
			if(minLength > length){
				minLength = length;
				optimal = new LinkedList<Integer>(arr);
				optimal.add(arr.get(0));
			}
			
		}
		
	}
	
	static final String KML_p1 = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n" + 
			"<kml xmlns=\"http://earth.google.com/kml/2.2\">\r\n" + 
			"<Document>\r\n" + 
			"<name>Pittsburgh TSP</name><description>TSP on Crime</description><Style id=\"style6\">\r\n" + 
			"<LineStyle>\r\n" + 
			"<color>73FF0000</color>\r\n" + 
			"<width>5</width>\r\n" + 
			"</LineStyle>\r\n" + 
			"</Style>\r\n" + 
			"<Style id=\"style5\">\r\n" + 
			"<LineStyle>\r\n" + 
			"<color>507800F0</color>\r\n" + 
			"<width>5</width>\r\n" + 
			"</LineStyle>\r\n" + 
			"</Style>\r\n" + 
			"<Placemark>\r\n" + 
			"<name>TSP Path</name>\r\n" + 
			"<description>TSP Path</description>\r\n" + 
			"<styleUrl>#style6</styleUrl>\r\n" + 
			"<LineString>\r\n" + 
			"<tessellate>1</tessellate>\r\n" + 
			"<coordinates>\r\n" + 
			"";
	
	static final String KML_p2 = "</coordinates>\r\n" + 
			"</LineString>\r\n" + 
			"</Placemark>\r\n" + 
			"<Placemark>\r\n" + 
			"<name>Optimal Path</name>\r\n" + 
			"<description>Optimal Path</description>\r\n" + 
			"<styleUrl>#style5</styleUrl>\r\n" + 
			"<LineString>\r\n" + 
			"<tessellate>1</tessellate>\r\n" + 
			"<coordinates>\r\n" + 
			"";
			
	static final String KML_p3 = "</coordinates>\r\n" + 
			"</LineString>\r\n" + 
			"</Placemark>\r\n" + 
			"</Document>\r\n" + 
			"</kml>\r\n" + 
			"";

}

/**
 * Coordinate node
 * @author LeoHong
 *
 */
class Coordinates{
	private double x;  // coordinate x
	private double y;  // coordinate y
	private double longtitude; // longitude
	private double altitude; // latitude
	
	/**
	 * Constructor with 4 arguments
	 * @param x coordinate x
	 * @param y coordinate y
	 * @param longtitude longitude
	 * @param altitude latitude
	 */
	Coordinates(double x, double y, double longtitude, double altitude){
		this.x = x;
		this.y = y;
		this.longtitude = longtitude;
		this.altitude = altitude;
	}
	
	/**
	 * Get coordinate x</p>
	 * Pre-condition: coordinates node is not null<br>
	 * Big-Theta: 1
	 * @return x coordinate
	 */
	public double getX(){
		return this.x;
	}
	
	/**
	 * Get coordinate y</p>
	 * Pre-condition: coordinates node is not null<br>
	 * Big-Theta: 1
	 * @return y coordinate
	 */
	public double getY(){
		return this.y;
	}
	
	/**
	 * Get longitude</p>
	 * Pre-condition: coordinates node is not null<br>
	 * Big-Theta: 1
	 * @return longitude
	 */
	public double getLon(){
		return this.longtitude;
	}
	
	/**
	 * Get Latitude</p>
	 * Pre-condition: coordinates node is not null<br>
	 * Big-Theta: 1
	 * @return latitude
	 */
	public double getAlti(){
		return this.altitude;
	}
	
	/**
	 * Set coordinate x</p>
	 * Pre-condition: coordinates node is not null<br>
	 * Post-condition: coordinate has been set<br>
	 * Big-Theta: 1
	 * @param x x coordinate
	 */
	public void setX(double x){
		this.x = x;
	}
	
	/**
	 * Set coordinate y</p>
	 * Pre-condition: coordinates node is not null<br>
	 * Post-condition: coordinate has been set<br>
	 * Big-Theta: 1
	 * @param y y coordinate
	 */
	public void setY(double y){
		this.y = y;
	}
	
	/**
	 * Set latitude</p>
	 * Pre-condition: coordinates node is not null<br>
	 * Post-condition: coordinate has been set<br>
	 * Big-Theta: 1
	 * @param alti latitude
	 */
	public void setAlti(int alti){
		this.altitude = alti ;
	}
	
	/**
	 * Set longitude</p>
	 * Pre-condition: coordinates node is not null<br>
	 * Post-condition: coordinate has been set<br>
	 * Big-Theta: 1
	 * @param lon longitude
	 */
	public void setLon(int lon){
		this.longtitude = lon;
	}
	
	
}

/**
 * Node for min Heap
 * @author LeoHong
 *
 */
class Node{
	private int vertex; // vertex of the graph
	private double mindis; // minimum distance
	
	/**
	 * Node constructor with 2 arguments</p>
	 * @param vertex vertex
	 * @param mindis minimum distance
	 */
	Node(int vertex, double mindis){
		this.vertex = vertex;
		this.mindis = mindis;
	}
	
	/**
	 * Get the vertex</p>
	 * Pre-condition: node is not null
	 * @return vertex
	 */
	public int getVertex(){
		return this.vertex;
	}
	
	/**
	 * Get minimum distance</p>
	 * Pre-condition: node is not null
	 * @return distance
	 */
	public double getMinDis(){
		return this.mindis;
	}
	


}

/**
 * MinHeap
 * @author LeoHong
 *
 */
class MinHeap{
	private Node[] Heap; // Heap array
	private int size;  // size of the Heap
	private int maxsize; // max size of the Heap 
	private static final int FRONT = 0; // first element indicator
	
	/**
	 * Constructor with one argument
	 * @param maxsize
	 */
	public MinHeap(int maxsize){
		this.maxsize = maxsize;
		this.size = 0;
		Heap = new Node [this.maxsize];
	}
	
	/**
	 * Parent index of the current element</p>
	 * Pre-condition: pos value is valid<br>
	 * Big-Theta: 1
	 * @param pos position of current element
	 * @return parent index
	 */
	private int parent(int pos){
		return (pos-1)/2;
	}
	
	/**
	 * Get the index of Left child of the current element</p>
	 * Pre-condition: pos value is valid<br>
	 * Big-Theta: 1
	 * @param pos position of current element
	 * @return index of left child
	 */
	private int leftChild(int pos){
		return (2*pos)+1;
	}
	
	/**
	 * Get the index of right child of the current element</p>
	 * Pre-condition: pos value is valid<br>
	 * Big-Theta: 1
	 * @param pos position of current element
	 * @return index of right child
	 */
	private int rightChild(int pos){
		return (2*pos)+2;	
	}
	
	/**
	 * Determine if the current node is a leaf of the Heap</p>
	 * Pre-condition: pos value is valid<br>
	 * Big-Theta: 1
	 * @param pos position of current element
	 * @return true if the current element is a leaf
	 */
	private boolean isLeaf(int pos){
		return leftChild(pos) >= this.size;
	}
	
	/**
	 * Swapping the two elements</p>
	 * Pre-condition: fpos and spos are valid<br>
	 * Post-condition: two element passed in are swapped with their position<br>
	 * Big-Theta: 1
	 * @param fpos front position
	 * @param spos second position
	 */
	private void swap(int fpos, int spos){
		Node temp;
		temp = Heap[fpos];
		Heap[fpos] = Heap[spos];
		Heap[spos] = temp;
	}
	
	/**
	 * Rearrange the whole min Heap</p>
	 * Pre-condition: pos is valid<br>
	 * Post-condition: Heap has been rearranged<br>
	 * Big-Theta(Best): 1<br>
	 * Big-Theta(Worst): Log n
	 * @param pos position of current node
	 */
	private void minHeapify(int pos){
		//System.out.println(isLeaf(pos));
		while(!isLeaf(pos)){
			int left = leftChild(pos);
			int right = rightChild(pos);
			//System.out.println("Right childe: " + right + " " + size);
			if(right >= size){
				if(Heap[pos].getMinDis() > Heap[left].getMinDis()){
					swap(pos, leftChild(pos));
					pos = left;
					//System.out.println(pos);
				}else{
					break;
				}
			}else{ 
				if(Heap[pos].getMinDis() > Heap[left].getMinDis() || Heap[pos].getMinDis() > Heap[right].getMinDis()){
					if(Heap[left].getMinDis() < Heap[right].getMinDis()){
						swap(pos, leftChild(pos));
						pos = left;
					}else{
						swap(pos, rightChild(pos));
					    pos = right;
					}
				}else{
					break;
				}
			}
		}
	}
	
	/**
	 * Check if a vertex is in the Heap</p>
	 * Pre-condition: Heap is not empty<br>
	 * Big-Theta(Best): 1<br>
	 * Big-Theta(Worst):n
	 * @param vertex vertex 
	 * @return true if the vertex is in the Heap
	 */
	public boolean containsValue(int vertex){
		for(int i = 0; i < size; i++){
			if(Heap[i].getVertex() == vertex){
				return true;
			}
		}
		return false;
	}
	/**
	 * Insert new element into the Heap</p>
	 * Pre-condition: Heap array is valid<br>
	 * Pos-condition: the element has been inserted to the Heap<br>
	 * Big-Theta(Best): 1<br>
	 * Big-Theta(Worst): log n
	 * @param element element to be inserted
	 */
	public void insert(Node element){
		Heap[size] = element;
		int cur = size++;
		//System.out.println(Heap[size].getVertex() + " Added");
		if(size > 1){
			while(Heap[cur].getMinDis() < Heap[parent(cur)].getMinDis()){
				//System.out.println((Heap[cur].getMinDis() + " v.s " + Heap[parent(cur)].getMinDis()));
				swap(cur, parent(cur));
				//System.out.println("Swapped " + cur + " with " + parent(cur));
				cur = parent(cur);
				//System.out.println("Parent for " + cur);
			}
		}
	}
	/**
	 * Modify the element in the heap</p>
	 * Pre-condition: element exist in the heap<br>
	 * Post-condition: element has been modified and Heap has been rearranged<br>
	 * Big-Theta(Best): 1<br>
	 * Big-Theta(Worst) n
	 * @param vertex vertex in scope
	 * @param value  value of the element
	 */
	public void modify(int vertex, double value){
		Node Node = new Node(vertex, value);
		for(int i = 0; i < size; i++){
			if(Heap[i].getVertex() == vertex){
     		Heap[i] = Node;
			}
		}
		minHeapify(FRONT);
	}
	
	/**
	 * Rearrange the minHeap</p>
	 * Pre-condition: Heap has more than one element<br>
	 * Post-condition: Heap has been rearranged<br>
	 * Big-Theta(Best): 1<br>
	 * Big-Theta(Worst): n log n
	 */
	public void minHeap(){
		for(int pos = size -1 ; pos >= 0 ; pos--){
			minHeapify(pos);
		}
	}
	
	/**
	 * Delete the minimum element of the Heap</p>
	 * Pre-condition: Heap is not empty<br>
	 * Big-Theta(Best): 1<br>
	 * Big-Theta(Worst) log n
	 * @return the deleted minimum element
	 */
	public Node deleteMin(){
		Node popped = Heap[FRONT];
		Heap[FRONT] = Heap[--size];
		minHeapify(FRONT);
		return popped;
	}
	
	/**
	 * See if the Heap is empty</p>
	 * Pre-condition: Heap is valid<br>
	 * Big-Theta: 1
	 * @return true if the Heap is empty
	 */
	public boolean isEmpty(){
		if(size <= 0)
		return true;
		return false;
	}
	
	/**
	 * Print out all elements in Heap</p>
	 * Pre-condition: Heap is valid<br>
	 * Big-Theta: n
	 */
    public void print()
    {
    	System.out.printf("Q: ");
        for (int i = 0; i < size ; i++ )
        {
        	System.out.printf("%.2f ",  Heap[i].getMinDis());
        	/*
            System.out.print(" PARENT : " + Heap[i].getVertex() + " LEFT CHILD : " + Heap[2*i].getVertex() 
                + " RIGHT CHILD :" + Heap[2 * i  + 1].getVertex());
            System.out.println();
            */
        } 
        System.out.println();
    }
 
}

/**
 * Tree Class with a set of operations
 * @author LeoHong
 *
 */
class treeNode{
	private double len; // length between parent and child
	private int recordIndex; // vertex value
	private treeNode parent; // parent of the node
	private LinkedList<treeNode> children = new LinkedList<treeNode>(); //children of the node
	
	/**
	 * Constructor with one argument
	 * @param index
	 */
	treeNode(int index){
		this.recordIndex = index;
	}
	
	/**
	 * Constructor with 3 argument
	 * @param index
	 * @param len
	 * @param parent
	 */
	treeNode(int index, double len, treeNode parent){
		this.len = len;
		this.recordIndex = index;
		this.parent = parent;
	}
	
	/**
	 * Setting up the parent of the current node </p>
	 * Pre-condition: current node is valid <br>
	 * Post-condition: parent node has been set <br>
	 * Big-Theta: 1
	 * @param parent parent node
	 */
	public void setParent(treeNode parent){
		parent.addChild(this);
		this.parent = parent;
	}
	
	/**
	 * Get the child node </p>
	 * Pre-condition: current node is valid <br>
	 * Big-Theta: 1 
	 * @param index index of the child node
	 * @return child node
	 */
	public treeNode getChild(int index){
		if(index >= children.size())
		return null;
		return children.get(index);
	}
	
	/**
	 * Get the length between parent and child vertex</p>
	 * Pre-condition: current node is valid<br>
	 * Big-Theta: 1
	 * @return length between parent and child vertex
	 */
	public double getLen(){
		return this.len;
	}
	
	/**
	 * Get the vertex value</p>
	 * Pre-condition: current node is valid<br>
	 * Big-Theta: 1
	 * @return vertex value
	 */
	public int getRecord(){
		return this.recordIndex;
	}
	
	/**
	 * Get the parent of the current node</p>
	 * Pre-condition: current node is valid<br>
	 * Big-Theta: 1
	 * @return parent of the current node
	 */
	public treeNode getParent(){
		return this.parent;
	}
	
	/**
	 * Adding the child node</p>
	 * Pre-condition: current node is valid<br>
	 * Post-condition: child node has been added to the children linkedlist<br>
	 * Big-Theta: 1
	 * @param node child node
	 */
	public void addChild(treeNode node){
		children.add(node);
	}

	/**
	 * Set the length between parent and child node</p>
	 * Pre-condition: current node is valid<br>
	 * Post-condition: the length has been set<br>
	 * Big-Theta: 1
	 * @param len length between parent and child node
	 */
	public void setLen(double len){
		this.len = len;
	}

	/**
	 * Retrieve the Hamiltonan linkedlist</p>
	 * Pre-condition: Hamiltonan is not null<br>
	 * Big-Theta: 1
	 * @return Hamiltonan linkedlist
	 */
    public LinkedList<treeNode> getHamilCycle(){
    	return Hamiltonan;
    }
	
    
	//private static int lastNode;
	private static LinkedList<treeNode> Hamiltonan = new LinkedList<treeNode>();
	
	/**
	 * Conduct preorder traversal and add each passing node to the Hamiltonan linked list</p>
	 * Pre-condition: root is valid<br>
	 * Post-condition: all nodes traversed have been passed into the linked list<br>
	 * Big-Theta: n
	 * @param root root node
	 */
	public void preOrderTraversal(treeNode root){
		//System.out.print(root.getRecord() + ", ");
		//lastNode = root.getRecord();
		Hamiltonan.add(root);
		for(treeNode each : root.children){
			//System.out.println("test" + each.getRecord());
			preOrderTraversal(each);
		}	
	}
	
	/**
	 * Conduct preorder traversal and add each passing node to the Hamiltonan linked list</p>
	 * Pre-condition: root is valid<br>
	 * Post-condition: all nodes traversed have been passed into the linked list<br>
	 * Big-Theta: n
	 */
	public void preOrderTraversal(){
		//System.out.println("test" + this.getRecord());
		preOrderTraversal(this);
		//System.out.print(this.getRecord());
		Hamiltonan.add(this);
	}

}
